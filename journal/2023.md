## 8.19

## emacs-like insert mode がとても良い

vi の利点はモーダルであること。  
モードを切り替えて文章を編集することで、少ないキーストロークで多彩な編集を実行することができる。  

一方で、vi のデメリットもまたモーダルであること。  
モーダルであるために、モード内に実装されていない操作を実行するためには、モードの切り替えが必要になる。  
例えば、挿入モードで編集した内容を保存するためには、一度ノーマルモードに戻って `:w` を入力することになる。  

特に挿入モード内だけで自由にテキストを編集することが難しい。  
カーソルを移動するだけでも、ホームポジションを崩して矢印キーを使うか、一旦ノーマルモードに切り替える必要がある。  

この問題を解決するのが `emacs-like insert mode`。  

emacs は vi のようなモーダルなエディタではない（emacs のモードは vi のモードとは異なる概念）。  
そのため、emacs を使いこなそうとすると、複数のキーを組み合わせた複雑なキーバインドを使用する必要がある。  
ただし、カーソル移動などの基本的なキー入力はとてもシンプルになっている。  

emacs のシンプルなキー入力の部分を vi の挿入モードで使用することができれば、テキスト編集がとても楽になる。  
モード切り替えが便利な場面ではモーダルの恩恵を享受することができ、最小ストロークで操作を実行できる。  
一方で、こまめにモードを切り替えたくない場面では、モードを切り替えることなく操作を実行できる。  

これを実現するには、Neovim の `init.lua` に以下を追加するだけで良い。  

````lua
-- emacs-like insert mode
vim.keymap.set('i', '<C-a>', '<Home>', { noremap = true })
vim.keymap.set('i', '<C-e>', '<End>', { noremap = true })
vim.keymap.set('i', '<C-b>', '<Left>', { noremap = true })
vim.keymap.set('i', '<C-f>', '<Right>', { noremap = true })
vim.keymap.set('i', '<C-p>', '<Up>', { noremap = true })
vim.keymap.set('i', '<C-n>', '<Down>', { noremap = true })
vim.keymap.set('i', '<C-l>', '<C-o>zz', { noremap = true })
vim.keymap.set('i', '<C-s>', '<C-o>:write<CR>', { noremap = true })
vim.keymap.set('i', '<C-q>', '<C-o>:quit<CR>', { noremap = true })
vim.keymap.set('i', '<C-d>', '<Del>', { noremap = true })
vim.keymap.set('i', '<C-k>', '<C-o>d$', { noremap = true })
````

macOS ユーザであれば、標準のテキストエディタアプリや、テキスト入力ボックスは emacs キーバインドが使用可能である。  
そのため、emacs キーバインドが vi の挿入モードでも使用できれば、大きなメリットがある。  

また、ターミナルのコマンドライン編集も emacs キーバインドで操作可能である。  
そのため、コマンドライン編集に慣れているならば、vi の挿入モードで emacs キーバインドを使用できることはメリットになる。  

同じような発想の Vim プラグインに `rsi.vim` が存在する。  

https://github.com/tpope/vim-rsi

## 8.15

### SRFI 49 を JavaScript にポーティングした
https://github.com/homma/srfi-49-js

Lisp は良い言語だと思うものの、S 式はちょっとしんどいなと思っていたので、パーサーの実装の勉強も兼ねて移植してみました  
コンパイラの教材は Lisp をターゲットにしたものが多いので、Lisp にトランスパイルするプログラムがあると良いなと思っていました

コードは元の実装そのままで JavaScript らしくないので、時間ができたら一から書き直したい

### SRFI 49 の `.` について
`.` を `EOF` 的に使用しているっぽい。

`read-block` の中で `read-item` の返り値に対して、`.` かどうかの判定をしている。  
コードを読んだ限りでは、`read-item` が `.` を返すことはなさそうに見える。  
`.` を返すのは `read-block-clean` ですが、`read-item` から `read-block-clean` が呼び出されるパスはなさそう。

### SRFI 49 の実装

#### Scheme
https://srfi.schemers.org/srfi-49/srfi-49.html  
https://github.com/ktakashi/sagittarius-scheme/blob/master/sitelib/srfi/%253a49.scm

#### Common Lisp
https://github.com/g000001/srfi-49/blob/master/srfi-49.lisp

### Lisp の苦手なところ
なんでもリストで表現する

````
class Person {
  name,
  age,
}
````

みたいなデータも

````
(name, age)
````

のように表現して `car` や `cdr` でアクセスしていることが多く、データにラベルがつかないので、読み下しづらい。  
値を作る時も `cons` を使っている。

関数から返る値が何を意味しているのかも明示的ではない。  
リストが返されていたとして、そのリストが何のデータなのかは一目見ただけでは分からない。

### SRFI 49: Indentation-sensitive syntax
https://srfi.schemers.org/srfi-49/srfi-49.html

## 8.14

### Prettier install
Nodebrew で Node.js をインストールした場合は、`~/.nodebrew/current/` 以下にインストールされる

````sh
% npm install -g prettier
````

`~/.npm` が作成されるが、不要そうなので消しておく

````sh
$ rm -rf ~/.npm
````

### `DARWIN_USER_DIR`
https://opensource.apple.com/source/Libc/Libc-1081.1.3/gen/confstr.3

````sh
$ getconf DARWIN_USER_DIR
$ touch $(getconf DARWIN_USER_DIR)foo.txt
````

アクセス許可不要でアプリに読み書きさせられるディレクトリ  
`/var/tmp` などを使うよりも良いのかもしれない

他のアプリから読み書きされても問題ないデータのみ配置して良い  
macOS のソフトウェアアップデートや再起動でデータが削除されるかもしれない  
rsync しておくと良いのかも

## 8.13

### Blender のダウンロード
スクリプトでバージョンを管理するため、CLI でダウンロードしたい

Homebrew でも NixPkgs でも `download.blender.org` からダウンロードしているみたい

https://github.com/Homebrew/homebrew-cask/blob/master/Casks/b/blender.rb  
https://github.com/NixOS/nixpkgs/blob/master/pkgs/applications/misc/blender/default.nix  

### Rust のインストール
````sh
$ cd
$ mkdir <installdir>/.cargo
$ ln -s <installdir>/.cargo .
$ mkdir <installdir>/.rustup
$ ln -s <installdir>/.rustup .
$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
````

#### evcxr
````sh
$ cargo install --locked evcxr_repl
$ alias rusti=evcxr
````

#### update
````sh
$ rustup update
````

#### uninstall
````sh
$ rustup self uninstall
````

### Neovim のリリースの確認
````sh
% curl -s -O https://api.github.com/repos/neovim/neovim/releases
````

````sh
% cat releases | jq '.[].tag_name'
"nightly"
"v0.9.1"
"stable"
"v0.9.0"
"v0.8.3"
...
````

````sh
% cat releases | jq '.[] | select(.tag_name == "v0.9.1") .assets[].name'
"nvim-linux64.tar.gz"
"nvim-linux64.tar.gz.sha256sum"
"nvim-macos.tar.gz"
"nvim-macos.tar.gz.sha256sum"
...
````

#### Latest
`latest` ディレクトリにあるのは `stable`  
`stable` がどのバージョンであるかは取得できない

````sh
 % curl -s -O https://api.github.com/repos/neovim/neovim/releases/latest
````

````sh
% cat latest | jq '.tag_name'
"stable"
````

````sh
% cat latest | jq '.assets[].name'
"nvim-linux64.tar.gz"
"nvim-linux64.tar.gz.sha256sum"
"nvim-macos.tar.gz"
"nvim-macos.tar.gz.sha256sum"
...
````

### Safari でウェブページの表示を拡大する

スタイルシートの設定でウェブページの表示を拡大・縮小できる  
以下をファイルに保存し、`Safari メニュー` -> `設定...` -> `詳細` -> `スタイルシート` で指定する

````css
body {
  zoom: 1.25;
}
````

JavaScript からは以下のように設定可能

````javascript
document.body.style.zoom = 1.25
````

https://developer.mozilla.org/ja/docs/Web/CSS/zoom

高精細・大画面のディスプレイでは必須設定だと思う  
Chrome には専用の zoom 設定が存在している

### Neovim のインストール時に実行しておくこと
config ファイルをインストールして、symlink を張る

https://github.com/homma/config-files/tree/main

`packer.nvim` のインストール

https://github.com/wbthomason/packer.nvim#quickstart

neovim を起動して `:PackerSync` でプラグインをインストールする

### Homebrew non-root install
しばらくは Homebrew を使うことにしました

````sh
$ cd
$ mkdir <installdir>/.homebrew
$ ln -s <installdir>/.homebrew .
$ curl -L https://github.com/Homebrew/brew/tarball/master | tar xz --strip 1 -C .homebrew
$ eval "$(.homebrew/bin/brew shellenv)"
$ brew update --force --quiet
$ chmod -R go-w "$(brew --prefix)/share/zsh"
$ echo 'export PATH=${HOME}/.homebrew/bin:${PATH}' >> ~/.zshrc
````

デフォルトのパスと異なるため、コンパイルが実行される

````sh
% brew install rsync
...
Warning: Building openssl@3 from source as the bottle needs:
...
built in 4 minutes 59 seconds
````

`brew install ripgrep` の場合はコンパイルは必要なかった

頻繁にインストール、アップグレードを実行するわけではないので、しばらくはこれで使ってみる

#### コンパイルが発生したパッケージ
- rsync
   - openssl のコンパイルが必要

#### コンパイルが発生しなかったパッケージ
- ripgrep
- jq

#### 未インストール
- Neovim
   - 別途インストールしたため
- stylua
   - 現時点では使用していない

### macOS で使用可能なパッケージシステム
non-root インストールしたい  
できれば Nixpkgs を使いたいところですが...

#### Homebrew
https://github.com/Homebrew/brew

non-root インストールは可能であるがサポートされていない

https://docs.brew.sh/Installation#untar-anywhere-unsupported  
https://github.com/Homebrew/brew/blob/master/docs/Installation.md#untar-anywhere-unsupported

#### Nixpkgs
https://github.com/nixos/nixpkgs

Linux では `nix-user-chroot` を使用することで non-root インストールも可能  
macOS では `nix-user-chroot` は使用できなさそう

https://nixos.wiki/wiki/Nix_Installation_Guide#Installing_without_root_permissions

`proot` や `nix-portable` を使用する方法も macOS では使用できないっぽい

#### MacPorts
https://www.macports.org

non-root インストール可能  
`--with-no-root-privileges` オプションを使用するみたい

https://gist.github.com/zadr/e9a090fb564451fb5c76db233fabf0d0  
https://gist.github.com/daggerok/d6c7ed8b9efa03b30ffd0e9f44cdd121

#### Fink
https://www.finkproject.org

dpkg ベース

#### pkgsrc
https://www.pkgsrc.org

non-root インストール可能  
`--unprivileged` オプションでユーザのホームディレクトリにインストールできる

https://www.netbsd.org/docs/pkgsrc/platforms.html

release は quarterly

https://www.pkgsrc.org/quarterly/

### Nix でパッケージをビルドする
https://github.com/justinwoo/nix-shorts/blob/master/posts/install-packages-from-files.md

### Nodebrew
実装は↓

https://github.com/hokaccha/nodebrew/blob/master/nodebrew

Node.js は↓の URL からダウンロードしている

https://nodejs.org/dist/

#### install
````sh
$ cd
$ mkdir <installdir>/.nodebrew
$ ln -s <installdir>/.nodebrew .
$ curl -L git.io/nodebrew | perl - setup
````

## 8.12

### パッケージ管理
ルートディレクトリではなく、ユーザのホームディレクトリ配下でパッケージを管理したい  

## 8.11

### YAML 風データのパース
既存の YAML のライブラリだと重複するキーがエラーになる

## 8.10

### BSD License のソフトウェアを fork した場合の LICENSE ファイルの書き方
https://github.com/openbsd/src/blob/master/usr.bin/vi/LICENSE

OpenBSD の LICENSE ファイルを参考にすればいい  
具体的には、Copyright ヘッダーを追加する

### MyLang をポーティングした
https://github.com/homma/mylang-js

Lexer にジェネレータを使用しているのが独特  
ジェネレータは先読みした時に値を戻せないという問題がある  
そのため、先読みした値を別途保存する必要性が発生している

JavaScript のジェネレータをちゃんと使ったのは初めてかも  
Map もあまり使ってこなかった  

しばらく前から class を型の代わりに使っているけど良い感じ

## 8.6

### 選択したテキストを右クリックでファイルに蓄積する

以下のスクリプトを作成し、Automator に登録した。  

Automator が改行コード `\n` を無視するので、`\n\0` を指定したら改行が出力された。  
`\n\0` の代わりに `\n\r` などでも良いみたい。  
謎の挙動。  

出力は `sjis` になる。  
`utf-8` にするのは大変そうだったので、今回は範囲外とします。  

````javascript
const app = Application.currentApplication();
app.includeStandardAdditions = true;

function appendToFile(text, file) {
  try {
    const fd = app.openForAccess(Path(file), { writePermission: true });

    app.write(text, { to: fd, startingAt: app.getEof(fd), as: "string" });
    app.closeAccess(fd);
    return true;
  } catch (e) {
    app.closeAccess(file);
    return false;
  }
}

function run(input, parameters) {
  // Automator ignores '\n' but '\n\0'
  const text = `${input[0]}\n\0`;

  // const output_dir = app.doShellScript("getconf DARWIN_USER_DIR");
  const output_dir = app.pathTo("home folder")
  const file = `${output_dir}/words.txt`;

  appendToFile(text, file);
}
````

参考  
https://developer.apple.com/library/archive/documentation/LanguagesUtilities/Conceptual/MacAutomationScriptingGuide/MakeaSystem-WideService.html

## 8.4

### YAML 的なものを parse する
- 行ごとに parse する // newline を見る
- インデント幅を変数に保持し、`INDENT` および `DEDENT` token を挿入する

- List と即値とコメントだけを扱いたいので、厳密には YAML ではない
   - yamlette

## 8.2

### evcxr
名前が覚えにくい  
eval context for rust  

名前を思い出しながら起動するので立ち上げが遅くなる  
alias をつけた方がいいかも  
rusti にしました

shared library を作成してロードするせいか、レスポンスが遅い  
これならインタープリタ方式の方が速くなるかもしれない  
CPU やファイルシステムが十分に速ければ問題ないのかもしれない

## 8.1

### cacao と cocoa どっち?
cacao は一般のアプリで使用されることを意図しているので、使いやすそう  
cocoa は servo で使用されているので、永続的に使用できそう

#### cacao
https://docs.rs/cacao/latest/cacao/  
https://crates.io/crates/cacao  
cocoa crate は servo と密結合しているので cacao create を作ったよとのこと  

https://docs.rs/cacao/latest/cacao/foundation/index.html  
cacao foundation は cocoa の core-foundation-rs の id の扱いに違和感があったからとのこと

#### cocoa
https://github.com/servo/core-foundation-rs  
https://blog1.mammb.com/entry/2023/03/03/182448  

Sample  
https://github.com/servo/core-foundation-rs/blob/master/cocoa/examples/hello_world.rs

#### RustKit
https://github.com/michaelwu/RustKit

### YAML S-exp
悪くないのでは

````
# fuctorial
- fun
- factorial
- - n
- - if
  - - ge
    - n
    - 1
  - 1
  - - multiply
    - n
    - - factorial
      - - minus
        - n
        - 1
````

````
# (list 1 2 "foo")
- list
- 1
- 2
- "foo"
````

````
# (+ 1 2 3 4)
- plus
- 1
- 2
- 3
- 4
````

````
# (lambda (x y) (+ x y))
- lambda
- - x
  - y
- - plus
  - x
  - y
````

#### another form
````
fun:
  name: factorial
  args:
    - n
  body:
    if:
      cond:
        ge:
         - n
         - 1
      true: 1
      false:
        multiply:
          - n
          - factorial:
              - minus:
                  - n
                  - 1
````

````
fun:
  - factorial
  - - n
  - if:
      - ge:
         - n
         - 1
      - 1
      - multiply:
          - n
          - factorial:
              - minus:
                  - n
                  - 1
````

````
fun:
  - factorial
  - [n]
  - if:
      - ge: [n, 1]
      - 1
      - multiply:
          - n
          - factorial:
              - minus: [n, 1]
````

````
# hello world
fun:
  - hello-world
  - []
  - print: 'hello world.'
````

````
# multi-line text
fun:
  - multi-line
  - []
  - print: |
      first line.
      second line.
````

````
fun:
  - program
  - [x, y]
  - begin:
      - let: [a, 10]
      - let: [b, 50]
      - print:
          +:
            - *: [a, x]
            - *: [b, y]
````

## 7.31

### Swift について
何度か Swift でプログラムを書こうとした後の印象

- Swift 自体は良い言語
- Swift に用意されている API を呼び出そうとすると、抽象度の高いものばかりで、実装したい操作まで辿り着くのが大変
  - フラグを変更したいだけなのに、専用の API がなく、ディクショナリに自分でデータを作成してから API を実行する必要があるなど
- Swift だけでは完結せず、C, ObjC, C++ を呼び出さざるを得なくなる
- 今でも ObjC ベースのドキュメントを参照する必要がある
- Swift のサンプルコードも少ない
- XCode が前提になっている
- REPL は使い勝手が良くない（起動が遅いし、プロンプトの設定もできない）

やりたいことを実装するのが大変で Swift を使うメリットが感じられない

例えば、USB デバイスを操作するプログラムを書くなら、IOKit などを使うよりも libusb を使った方が何倍も簡単  
PDF を編集するプログラムなら PDFKit より Python なんかで市井のライブラリを使った方が楽

### winit
https://komi.dev/post/2021-07-20-enabling-ime-in-alacritty/  
https://github.com/rust-windowing/winit/pull/1979

macOS でも日本語の入力に対応しているみたい

### REPL の実装に関するノート

基本は以下になるみたい
- コードをパースして、宣言、文、式などに分類する
- パースしたコードの種類に合わせてラッパーを追加する
- 変数や関数は専用のデータ構造を用意してストアする
- 変数や関数への参照はそちらを向くように書き換える
- 共有ライブラリとしてコンパイルする
- ロードして実行する
- REPL のプロセスと実行プロセスは分ける（サブプロセスにする）

共有ライブラリを作成できない言語では難しい  

#### Rust
https://github.com/evcxr/evcxr/blob/main/evcxr/HOW_IT_WORKS.md  
https://github.com/evcxr/evcxr/blob/main/COMMON.md#limitations

実装については冒頭に記載した形になっている  
他の Crate からマクロをインポートすることができないという制限がある

#### D
https://github.com/callumenator/dabble/blob/master/readme.md  
https://github.com/dlang-community/drepl/blob/master/src/drepl/engines/dmd.d

https://qiita.com/sobaya007/items/66876036bb318c368f5c  
https://karita.xyz/notes/d-jupyter.html

#### C
https://neugierig.org/software/c-repl/

#### Zig
https://github.com/ziglang/zig/issues/596

実装が難しいポイントが書かれている

#### Crystal
https://github.com/crystal-lang/crystal/issues/681

コンパイラとは別の実装として作成されている

#### Swift
https://www.swift.org/lldb/

デバッガを使用した特殊な実装  
起動が遅いのが難点

#### Go
Go 言語には冒頭に挙げたような実装の REPL は存在しないみたい  

https://github.com/x-motemen/gore

これは過去のコードを全て実行するみたいなので、逐次実行ではない

### "Building and loading dynamic libraries at runtime in Swift"
https://theswiftdev.com/building-and-loading-dynamic-libraries-at-runtime-in-swift/

### SwiftSyntax
https://github.com/apple/swift-syntax

これで REPL 作成できないかな

算術演算くらいなら実装できるかも

### 欲しいもの
このページのような雑記帳（マイクロブログ）

- Markdown で記入できる
- 文字数などの制限がない
- エントリー単位でデータを蓄積
  - title, body, date, tags
- 全てのエントリーを一覧表示できる
- 個別のエントリーを単独で表示できる
- タグで分類できる
- ログインしてデータを作成
- CLI からもデータを push 可能
- git で管理される

GitHub で実現できたら楽なのですが...

Issues を使う方法は abuse っぽい感じがする

https://egghead.io/blog/github-issues-powered-blog

ディレクトリに Markdown を作成したら、良い感じで読み出してほしい

### Python ctypes
https://docs.python.org/ja/3/library/ctypes.html

`CDLL` でライブラリをロードできる

### REPL for D Programming Language

#### drepl
https://github.com/dlang-community/drepl  
https://github.com/dlang-community/drepl/blob/master/src/drepl/interpreter.d  
https://github.com/dlang-community/drepl/blob/master/src/drepl/engines/dmd.d

以下のような操作で REPL を実現している
- 入力を宣言 (Decl)、文 (Stmt)、式 (Expr) に分別
- それぞれを C 言語のライブラリとしてコンパイル
- ライブラリをロード

変数の再定義やコンパイル単位をまたぐ参照をどうしているのかはよく分からず

Swift でも同じようなことができないかな

https://karita.xyz/notes/d-jupyter.html にも情報があった

#### dabble
https://github.com/callumenator/dabble

別の実装  
c-repl を参考にしているとのこと

https://neugierig.org/software/c-repl/

via https://forum.dlang.org/post/xemrxpwusliqsegkqtbx@forum.dlang.org

### OCaml and UTF8
https://rosettacode.org/wiki/String_length#Character_Length_72

UChar モジュールを使用すれば、文字列を UTF8 として操作する処理を実装できる
