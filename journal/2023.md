## 11.16

### Clang: modulemap
- https://clang.llvm.org/docs/Modules.html

C 風のコメントを記載できる

### Swift: Swift から C ライブラリを呼び出す

Package.swift は不要でした

#### ファイル

````
main.swift
module.map
````

module.map は module.modulemap と同じ

#### module.map 

````
module curses [system] {
  header "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/curses.h"
  link "/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/lib/libcurses.tbd"
  export *
}
````

`/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk` 以下のヘッダーファイルを指定すると `redefinition of module` エラーが発生する

#### main.swift

````
import curses

initscr()
cbreak();
noecho();

let a = getch();
endwin();

print(a);
````

#### compile

````
$ swiftc main.swift -I . -lcurses
````

`-lcurses` でリンクしないと `ld: warning: Could not find or use auto-linked library` エラーが発生する

#### run

````
$ ./main
````

### Darwin.ncurses

以下の modulemap に定義されているから import できるものと思われる

- /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include/ncurses.modulemap

### Swift: SceneKit
- https://developer.apple.com/documentation/scenekit

3D scene のためのフレームワーク

物理シミュレーションなども実装されている

- https://developer.apple.com/documentation/scenekit/physics_simulation

Xcode に SceneKit Scene Editor というエディタも用意されているみたい

### Swift: AVAudioPlayer
- https://developer.apple.com/documentation/avfaudio/avaudioplayer

NSSound とほとんど同じようなインターフェイスのクラスが存在していた

MPMusicPlayerController というクラスもある

- https://developer.apple.com/documentation/mediaplayer/mpmusicplayercontroller

### C#: LibraryImport
- https://learn.microsoft.com/ja-jp/dotnet/standard/native-interop/pinvoke
- https://learn.microsoft.com/ja-jp/dotnet/standard/native-interop/pinvoke-source-generation

AOT コンパイラでは DllImport を利用することができないため、LibraryImport が用意されているということみたい

## 11.15

### Swift: ObservableObject
- https://developer.apple.com/documentation/combine/observableobject

- 変動する値を提供するオブジェクトに使用する

### イベントループの形
- フレームワークがメインループを実行するタイプ
  - GUI では一般的
  - Update など指定された名前の関数が自動で呼び出される

- メインループを自分で作成するタイプ
  - XNextEvent のようにイベントを取得して自分でループを回す
  - Raylib は SetTargetFPS で指定したフレームレートに従って、EndDrawing がタイミングを調整する

メインループを自分で作成する方が更新処理を行う関数に与えたい情報を自分で選択できるので柔軟

### curses timeout
- getch 関数のタイムアウトを設定できる
- これを使用してイベントループを作成できると思われる

- WaitNextFrame 的な関数を作成すると良さそう

### MP3 ファイルの整理
- M3U ファイルでプレイリストを作成できる
  - https://datatracker.ietf.org/doc/html/rfc8216

- MP3TAG アプリでメタデータを編集し、レーティングなどを追加できる
  - https://www.mp3tag.de/en/

## 11.14

### Swift Package
- https://docs.swift.org/package-manager/PackageDescription/PackageDescription.html

## 11.13

### 簡単な MP3 Player

`ncurses` を使って、中断・再開・早送り・早戻し・終了を実行できるようにしました

````swift
import AppKit
import Darwin.ncurses

let args = CommandLine.arguments;

guard args.count == 2 else {
  print("Usage: ./mplay <FILE>");
  exit(1);
}

let file = args[1];

guard let sound = NSSound.init(contentsOfFile: file, byReference: true)
else {
  print("please specify a music file.");
  exit(1);
}

sound.play();

initscr();
cbreak();
noecho();

addstr("q: quit, p: pause, r: resume, b: back, f: forward ");

while true {
  let ch = UnicodeScalar(UInt8(getch()));
  switch ch {
    case "q":
      endwin();
      print("quit.");
      sound.stop();
      exit(0);
    case "p":
      sound.pause();
    case "r":
      sound.resume();
    case "b":
      sound.currentTime = (sound.currentTime < 10) ? 0 : sound.currentTime - 10;
    case "f":
      sound.currentTime = sound.currentTime + 10;
    default:
      break;
  }
}
````

実行例

````sh
$ swiftc mplay.swift
$ ./mplay /System/Library/Sounds/Ping.aiff
````

### NSSound を使用して MP3 ファイルを再生する

以下の Swift コードで MP3 ファイルの再生は実行できた

````swift
import AppKit

let args = CommandLine.arguments;

if args.count < 2 {
  print("Usage: ./play <FILE>");
  exit(1);
}

let file = args[1];

guard let sound = NSSound.init(contentsOfFile: file, byReference: true)
else {
  print("please specify a music file.");
  exit(1);
}

sound.play();

Thread.sleep(forTimeInterval: sound.duration);
````

実行例（以下は AIFF ファイルを指定していますが、MP3 でも実行可能）

````sh
$ swiftc play.swift
$ ./play /System/Library/Sounds/Ping.aiff
````

### MP3 Player を作りたい

ミュージックアプリの使い勝手が微妙なので、ちょっとした MP3 Player を自作したい  
ミュージックアプリは Apple Music 専用にし、購入した MP3 ファイルは自作のプレイヤーで再生できると嬉しい  
手持ちの Android 端末でも動かせると尚良い

MP3 ファイルの再生部分を自作するのは大変そうなので、ライブラリを利用したい  
ライブラリに必要な機能は以下

- MP3 ファイルを読み込める
- 音楽を再生できる
- 再生を停止できる
- 決まった場所から再生できる

イコライザなどはあったら嬉しいが、なくても良い

用途に合いそうなライブラリは以下が見つかった

- NSSound
- SLD3_mixer
- Godot AudioStreamPlayer

まずは NSSound から試してみたい

macOS 上の MP3 ファイルの再生は `afplayer` コマンドで実行できますが、再生の停止と途中からの再生ができないので、別の方法が必要

#### NSSound
- https://developer.apple.com/documentation/appkit/nssound

インストール不要  
macOS のみ

#### SDL3_mixer
- https://wiki.libsdl.org/SDL3_mixer/CategoryAPI

シンプルで簡単そう  
移植性も高い

#### Godot AudioStreamPlayer
- https://docs.godotengine.org/ja/4.x/classes/class_audiostreamplayer.html#class-audiostreamplayer-method-play

Godot の使い方を勉強したい

### Tone.js
- https://tonejs.github.io

### dotnet-sdk のインストール
Homebrew でインストール可能

````
$ brew install dotnet-sdk
````

## 10.30

### Unity で HIDAPI Library を使用する

HIDAPI Library は Homebrew でインストールできる

````
$ brew install hidapi
````

`libhidapi.0.14.0.dylib` を `libhidapi.dylib` にリネームして適当な場所にコピーする

````
$ cd <somewhere>
$ cp $(brew --prefix hidapi)/lib/libhidapi.0.14.0.dylib libhidapi.dylib
````

`libhidapi.dylib` を Unity プロジェクトの `Assets` ディレクトリーに drag and drop する  

Unity のスクリプトからは `DllImport` で `hidapi` を指定すれば読み込める

## 10.4

### Neovim で Visual モードで選択した文字列をクリップボードの文字列に置き換える
Visual モードで選択した状態で以下を実行する

````
"_s<C-v>
````

`"_s` で選択された文字列を削除しブラックホールレジスタに格納  
`<C-v>` でクリップボードからペースト

`"_` を指定しないと、`s` で削除した文字列でクリップボードが上書きされてしまう  
`"_` を指定して、ブラックホールレジスタに格納することで上書きを回避する

以下でも同じことができた  
`<C-g>` で Select モードに移行してからペースト

````
<C-g><C-v>
````

単純に `p` するだけでも置き換えができた  
`p` だと、選択した文字列を削除してペースト、元の文字列はレジスタに格納される  
`P` だと、選択した文字列を削除してペースト、レジスタは変更されない

## 10.1

### AHRS: Attitude and Heading Reference Systems
https://ahrs.readthedocs.io/en/latest/index.html  
https://github.com/Mayitzin/ahrs  

### Fusion
https://github.com/xioTechnologies/Fusion

### Safari で開いているウェブページを PDF に保存する

`osascript` コマンドで以下のスクリプトを実行する

````applescript
-- generate file name as yyyy_mm_d_time.pdf
set y to year of (current date) as string
set m to month of (current date) as number
set d to day of (current date) as string
set t to time of (current date) as string
set n to y & "_" & m & "_" & d & "_" & t & ".pdf"

-- make the window as the front window
tell application "Safari" to activate

tell application "System Events"
  tell process "Safari"

    -- click `export to pdf` menu
    click menu item "PDFとして書き出す…" of menu "ファイル" of menu bar 1

    -- wait until the sheet gets opened
    repeat until exists sheet 1 of window 1
    end repeat

    -- set file name
    set value of text field 1 of sheet 1 of window 1 to n

    -- click save button
    click button "保存" of sheet 1 of window 1
  end tell
end tell
````

## 9.26

### Raylib SetTargetFPS
`SetTargetFPS()` を使用すると、フレームレートを固定することができる  
`EndDrawing()` の中でタイミングを調整している

https://github.com/raysan5/raylib/blob/master/src/rcore.c#L2369

### Lua CPP
FFI で使用するための C プリプロセッサの実装が存在する  

- https://github.com/m-schmoock/lcpp
- https://github.com/facebookresearch/CParser

LuaJIT 側でも C プリプロセッサを持つという提案がされている

- https://github.com/LuaJIT/LuaJIT/issues/27

個人的な使用範囲では、現時点では Clang の C プリプロセッサを使用するのが現実的  
Lua で実装された C プリプロセッサまで動作確認をする余裕がないため

## 9.18

### GDExtension
[Hello GDExtension from C: an in-depth introduction](https://github.com/gilzoide/hello-gdextension/tree/main/1.hello-c)

Godot から C のライブラリを呼び出すサンプル  
GDExtension という形で接続用のコードを書く必要がある

汎用のブリッジがあると嬉しい

### Class は必要か
JavaScript や Lua のようなプロトタイプベースのオブジェクト指向でも十分  
一般的に Class と関連づけて求められているような継承の機能は不要

不要
- 継承
- 差分プログラミング

そもそも継承自体がすでに時代遅れになっている感がある

ただし、Class の以下の機能はプロトタイプベースの言語でも有用

有用
- データ型としての Class
- オブジェクトを簡潔に定義する構文としての Class
- メンバーを明示的に管理するための Class
- コンストラクターを明示するための Class

### LuaJIT から raylib を使用する
https://github.com/homma/raylib-luajit

## 9.17

### Raylib Install
https://github.com/raysan5/raylib/wiki/Working-on-macOS

````
$ brew install raylib
````

ヘッダーファイルなどには以下でアクセス可能

````
$ /bin/ls -F $(brew --prefix raylib)/
````

### Neovim Command Key
https://neovim.io/doc/user/intro.html#%3CD-

0.9.2 からキーバインドにコマンドキーを使用できるようになったみたい

````
<d->
````

OS と被るので使う機会は少ないかもしれませんが

## 9.13

### lis.py を JavaScript にポーティングした
https://github.com/homma/lispy-js

以下の記事に沿って実装しました

[(How to Write a (Lisp) Interpreter (in Python))](https://norvig.com/lispy.html)

## 9.11

### LuaJIT から OpenGL を使用する
https://github.com/homma/opengl-luajit

`#define` されている定数について対応が必要

## 9.10

### LuaJIT から Joy-Con にアクセスする
https://github.com/homma/joycon-luajit

6 軸センサーの値は取れるようになった  
動作確認用の UI が必要

[`hid_set_nonblocking()`](https://github.com/libusb/hidapi/blob/master/hidapi/hidapi.h#L372-L391) で non-blocking モードも試す必要がありそう

## 9.9

### Julia の FFI と embedding
https://docs.julialang.org/en/v1/manual/calling-c-and-fortran-code/  
https://docs.julialang.org/en/v1/manual/embedding/  

簡単そう

### Luaref

````
:h luaref
````

Lua 5.1 のリファレンスを Neovim 内で参照できる

HTML 版は以下

https://neovim.io/doc/user/luaref.html

Lua 5.1 Reference Manual は以下

http://www.lua.org/manual/5.1/

### HIDAPI を LuaJIT から呼び出す
https://github.com/homma/hidapi-luajit

### libYAML
https://github.com/yaml/libyaml

C で実装された YAML のパーサー

### LuaSQLite3
http://lua.sqlite.org/index.cgi/doc/tip/doc/lsqlite3.wiki

### IMGUI tutorial
https://solhsa.com/imgui/  

Lua バージョン

https://github.com/malkia/ufo/tree/master/samples/SDL/imgui

### LuaRocks
https://luarocks.org

## 9.8

### hidapi install
````
$ brew install hidapi
````

### crate-type cdylib
https://doc.rust-lang.org/reference/linkage.html  
https://doc.rust-lang.org/cargo/reference/cargo-targets.html  
https://bun.sh/docs/api/ffi  

他のプログラミング言語から呼び出せるライブラリを作成する場合に指定する

## 9.7

### LuaJIT FFI with Clang

Clang の `-ast-print` オプションを使用すると、ヘッダーファイルから LuaJIT の FFI 用のコードを生成することができる

````sh
$ SDK_DIR=/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk
$ SDK_INCLUDE=${SDK_DIR}/usr/include
$ TOOLCHAIN_DIR=/Library/Developer/CommandLineTools
$ CLANG_VER=$(/bin/ls -1 ${TOOLCHAIN_DIR}/usr/lib/clang | tail -1)
$ TOOLCHAIN_INCLUDE=${TOOLCHAIN_DIR}/usr/lib/clang/${CLANG_VER}/include
$ 
$ echo 'local ffi = require("ffi")' >> ncurses.lua
$ echo 'ffi.cdef[[' >> ncurses.lua
$ clang -cc1 -ast-print ${SDK_INCLUDE}/ncurses.h -I ${SDK_INCLUDE} -I ${TOOLCHAIN_INCLUDE} -D _VA_LIST | sed 's/_Nullable//' >> ncurses.lua
$ echo ']]' >> ncurses.lua
$ echo 'local ncurses = ffi.load("ncurses")' >> ncurses.lua
$ echo 'local win = ncurses.initscr()' >> ncurses.lua
$ luajit ncurses.lua
````

### ヘッダーファイルのパス
基本的なヘッダーファイルのパス

````
SDK_DIR=$(xcrun --show-sdk-path)
SDK_INCLUDE=${SDK_DIR}/usr/include
````

以下でも同じだと思われる

````
SDK_DIR=/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk
SDK_INCLUDE=${SDK_DIR}/usr/include
````

clang が提供するヘッダーファイル

````
TOOLCHAIN_DIR=$(dirname $(xcrun --find clang) | sed 's#/usr/bin##')
TOOLCHAIN_INCLUDE=${TOOLCHAIN_DIR}/usr/lib/clang/14.0.3/include
````

以下でも同じだと思われる

````
TOOLCHAIN_DIR=/Library/Developer/CommandLineTools
TOOLCHAIN_INCLUDE=${TOOLCHAIN_DIR}/usr/lib/clang/14.0.3/include
````

## 9.6

### Clang AST
https://clang.llvm.org/docs/IntroductionToTheClangAST.html  
https://clang.llvm.org/docs/InternalsManual.html

AST をダンプできる

### Rust bindgen
https://github.com/rust-lang/rust-bindgen  
https://rust-lang.github.io/rust-bindgen/  
https://crates.io/crates/bindgen  

これで C のライブラリをラップして `evcxr` から呼び出すと良いかもしれない  

### Lua について
JavaScript と同じプロトタイプベースのオブジェクト指向なのが良さそう  
構文はシンプルで、括弧が少ないのが良い  

FFI の仕組みがあり、C のライブラリを呼び出すことが可能  
C のライブラリを使用したい場合に、C を書く必要がない

C のプログラムに埋め込むことができるので、可搬性が高い  
Android のプログラムでも、Java -> JNI -> C -> Lua のような感じで使用できそう

Neovim で使用されているので、Lua のコードは使い回しができそう

配列が 1 スタートなのは、割と良さそうな感じがする（違和感はない）

LuaJIT の実行速度は速いみたいなので、その点の不安がない

REPL があるので使いやすい  

自分で実装することも可能かもしれない

### LuaJIT install
公式ではバイナリを配布しておらず、ソースコードからインストールするようにガイドされている  
今回は `Homebrew` でインストールしました

````sh
$ brew install luajit
````

https://luajit.org  
https://github.com/LuaJIT/LuaJIT  

### Swift REPL でライブラリをロードできない
参考手順

https://gist.github.com/dabrahams/c7de10507e98463e71bf8b4586f5e51a

手元の環境では `Couldn't lookup symbols` エラーが発生してしまう

````
expression failed to parse:
error: Couldn't lookup symbols:
````

上記の参考手順以外でも同じエラーが発生する

Swift Driver を無効にしても問題は解消せず  

補完などを実行するとライブラリ内のシンボルは見えている  
ただ、正しくロードできていないみたい  
詳しい原因は不明  
検索しても解決策は見つからず  

調査する時間がないので、一旦 Swift の使用は保留  

### REPL and Swift Packages
https://www.swift.org/blog/swiftpm-repl-support/  

### Swift Packages
https://github.com/apple/swift-package-manager  

C のコードを呼び出す例

https://github.com/apple/swift-package-manager/tree/main/Fixtures/CFamilyTargets

## 9.5

### Clang Modules
https://clang.llvm.org/docs/Modules.html  
https://github.com/apple/swift-package-manager/blob/main/Documentation/Usage.md

## 9.4

### FFI
- C のライブラリを使いたい
- C は書きたくない
- C のライブラリを他の言語から使いたい
- Stub コードは書きたくない
- できれば REPL から使いたい

Python の `ctypes` は上記を全て満たしている

https://docs.python.org/ja/3/library/ctypes.html

JavaScript だと難しい  
`Node.js` 自体は動的なライブラリのロードをサポートしていないと考えた方が良さそう  
`process.dlopen` が存在するが、これは汎用的に使用されるためのものではない

https://nodejs.org/api/process.html#processdlopenmodule-filename-flags  

標準ライブラリでの FFI については議論中

https://github.com/nodejs/node/issues/46233  

代わりに `node-ffi-napi` などの外部ライブラリを使用することになる  
ライブラリから更に他の複数のライブラリが呼び出されている  
最終更新から時間が経っている

https://github.com/node-ffi-napi/node-ffi-napi  
https://github.com/node-ffi/node-ffi/wiki/Node-FFI-Tutorial  

`Deno` や `Bun` は `dlopen` の使用がサポートされている  
`Deno` は `Unstable` ではありますが

https://deno.land/api@v1.36.4?s=Deno.dlopen&unstable=  
https://bun.sh/docs/api/ffi

## 9.3

### libusb/hidapi
https://github.com/libusb/hidapi

## 9.2

### Electron ES Modules support
8/31 の Nightly リリースのバージョン 28 から対応

https://github.com/electron/electron/issues/21457

インストール方法は以下の通り

````
$ npm install electron-nightly@v28.0.0-nightly.20230831
````

現在のリリースは 26.1.0 なので、正式版での対応はまだしばらくかかるかも

https://releases.electronjs.org

これで `.mjs` ファイルにできたり、トップレベル `await` が使えるようになるのかな

## 9.1

### Neovim extmark
https://neovim.io/doc/user/api.html#api-extmark

## 8.31

## 技術ドキュメントの読み方
- 2 回読む
- 最初は流して読んで全体を把握する
- 2 回目は詳しく確認しながら読む

流し読みなら途中で挫折することがない

## A or B

#### A か B で迷った時
- どちらを選択すべきか判断する材料をたくさん持つ
- 判断材料をたくさん集められるようにする
- 少ない材料から適切な判断ができるようにする

適切な情報をベースに判断する

#### A か B か決められない時
- 判断コストが増大した場合は A も B も両方やる
- 優先順位を決めて両方に対応する
- 順番に対応すれば良い

判断コストを評価基準に入れる

決めることができないなら両方やれば良い  
やってみてから判断する  
試してしまった方が早い  
試したことは経験値になる

まずは簡単な方から試す  
少ない労力で始める  
開始するまでの時間をなるべく小さくする

選択肢が do or do not の場合は do  
do not を選択すると、その後も気になり続ける可能性がある

#### 判断基準
- A (or B) を選択するメリット
- B (or A) を選択しないメリット
- A or B で迷うコスト

#### ex.
ある処理を JavaScript で実装するか Python で実装するか悩むなど  

### Pug
https://github.com/pugjs/pug

`pug-cli` をインストールするとコマンドラインから呼び出すことができる

https://github.com/pugjs/pug-cli

## 8.30

### Neovim no highlight
`<C-L>` でハイライトを消すことができる  
`:nohl` より簡単

特に JIS 配列のキーボードだと間違えて `;` を押してしまうことがあった  

### "Natural Language Processing with Python"
https://www.nltk.org/book/

### 『Python による日本語自然言語処理』
https://www.nltk.org/book-jp/ch12.html

### LOUDS
簡潔データ構造 LOUDS の解説（全12回、練習問題付き）  
https://takeda25.hatenablog.jp/entry/20120421/1335019644

### nvi-m17n
https://cdn.netbsd.org/pub/pkgsrc/current/pkgsrc/editors/nvi-m17n/

## 8.29

### FNV Hash
http://www.isthe.com/chongo/tech/comp/fnv/index.html  
https://datatracker.ietf.org/doc/html/draft-eastlake-fnv-06

## 8.28

### SDL とイベントループ
SDL のイベントはキューイングされて `SDL_PollEvent` で取り出せる

https://wiki.libsdl.org/SDL2/SDL_PollEvent

`SDL_PollEvent` はブロックするわけではないみたい  
ブロックするのは `SDL_WaitEvent`

https://wiki.libsdl.org/SDL2/SDL_WaitEvent

X11 は `ConnectionNumber` マクロでファイルディスクリプタを取り出し、それに対して `select`/`poll` を行うことで、X11 以外のイベントも同時に待つことができるみたい  
SDL はネットワークプロトコルではないので、そういうことはできなさそう

SDL 以外のイベントも処理したい場合は、別スレッドやプロセスを作成し、キューイングするなどの仕組みが必要  

````
loop:
  SDL のイベントキューのイベントを取り出し (SDL_PollEvent) 処理する
  SDL 以外のイベントキューのイベントを取り出し、処理する

io_thread:
  block して I/O を待機、I/O が発生したらイベントキューに格納する
````

### TOML
https://toml.io/ja/v1.0.0-rc.2

テーブルでツリーを作ることは可能だが、キーが冗長になる  
インデントで入れ子を表現する YAML と違って、キーの書き間違いでデータ構造に問題が発生する可能性がある

そもそも積極的にツリー構造を定義するためのフォーマットではなさそう

````
[html]
tag = html
width = 640
height = 400

[html.body.div1.div2a]
tag = div
class = mydiv
height = 30
width = 100

[html.body.div1.div2b]
tag = div
class = mydiv
height = 30
width = 100
````

こんな感じに書けたら良いのかな

````
[html.body as body]
...

[body.div]
...

````

こういうこともできない

````
[body.div[0].span]
[body.div[1].span]
````

`ミニマルな設定ファイルフォーマット`なので、用途外ということだと思われる

## 8.27

### SDL for Android
ビルド用のスクリプトが存在している

https://github.com/libsdl-org/SDL/blob/main/build-scripts/androidbuild.sh

https://wiki.libsdl.org/SDL2/Android  
https://github.com/libsdl-org/SDL/blob/main/docs/README-android.md

### Double Array Trie
ダブル配列トライについての記事

[Darts: Double-ARray Trie System](http://chasen.org/~taku/software/darts/)  
[Double-Array Articles](http://nanika.osonae.com/DArray/index.html)  
[【Pythonでテキスト処理】Double arrayでTrieを実装してみた](https://www.altus5.co.jp/blog/trie/2017/11/13/double-array/)  

[テキスト処理入門：Pythonで高速な辞書を作ろう（その1）](https://www.kodensha.jp/index/blog/2018/11/14/3877/)  
[（その2）](https://www.kodensha.jp/index/blog/2018/11/14/3882/)  
[（その3）](https://www.kodensha.jp/index/blog/2018/11/14/3884/)  
[（その4）](https://www.kodensha.jp/index/blog/2018/11/14/3885/)  

[情報系修士にもわかるダブル配列](https://takeda25.hatenablog.jp/entry/20120219/1329634865)

### 宣言的 UI について
既存の仕組みが用意されていなくとも、関数呼び出しの入れ子として近いものを実装できそう  
HyperScript 的な感じにすればパーサーを書く必要がない

https://github.com/hyperhype/hyperscript

あとは、CSS 的な仕組み、カスタムウィジェット、レイアウトシステムが必要  
ウィジェットとレイアウトについては Tk が参考になる

https://www.tcl.tk/man/tcl/TkCmd/contents.html

### Lua on Lite XL
C で実装された API を Lua から呼び出している  
Lua から呼び出す API は api ディレクトリに実装されている

https://github.com/lite-xl/lite-xl/tree/master/src/api

SDL のグラフィック API を呼び出している部分は `renderer.c`  
ただし、フォント関連と矩形の描画しか使用されていない模様  
実際、スクリーンショットを見ると UI は矩形で実装されているみたい  
必要十分であるし、割り切った実装で面白い  

IME の処理など、イベント関連は `system.c` に実装されている  
IME の処理は `SDL_TEXTEDITING` の部分

イベントリスナー `SDL_PollEvent` は `system.c` で実装されている  
Lua 側には `poll_event` として公開されている  
イベントループは Lua 側で実行している

## 8.26

### Safari の URL 欄下に表示されるサジェストを消す
`設定...` >> `検索` >> `お気に入りを表示` のチェックを外す

動作が遅く、誤クリックすることが多かったので

### Electron でローカルのファイルを読み出す
[チュートリアル](https://www.electronjs.org/ja/docs/latest/tutorial/tutorial-preload)のファイルを修正して以下を追加する

````javascript
// main.js

const fs = require('fs')
const process = require('process')

app.whenReady().then(() => {
  const home = process.env["HOME"];
  const file = path.join(home, "myfile.txt");
  ipcMain.handle('myread', () => fs.readFileSync(file, "utf8"));

  createWindow()
})
````

````javascript
// preload.js

const { contextBridge, ipcRenderer } = require('electron')

const ipc = {
  myread: () => ipcRenderer.invoke('myread'),
}

contextBridge.exposeInMainWorld('ipc', ipc)
````

````javascript
// renderer.js

ipc.myread().then((val) => {
  information.innerText = val;
})
````

### Electron の renderer からログを出力する
`ELECTRON_ENABLE_LOGGING` 環境変数を使用するか `--enable-logging` オプションを指定する

````sh
ELECTRON_ENABLE_LOGGING=true
````

`package.json` にて

````
  "scripts": {
    "run": "electron . --enable-logging",
````

https://www.electronjs.org/ja/docs/latest/api/environment-variables  
https://www.electronjs.org/ja/docs/latest/api/command-line-switches#--enable-loggingfile

### Electron の renderer プロセスから Node.js の API を呼び出す
`nodeIntegration` を `true` にすることで呼び出せるようになる。  
ただし、非推奨。

https://www.electronjs.org/ja/docs/latest/tutorial/security

renderer プロセスで外部情報を扱う場合は設定を変更しない。

## 8.25

### End-to-end encryption with OpenSSL and Git
https://github.com/remotely-save/remotely-save/blob/master/docs/encryption.md  
https://gist.github.com/polonskiy/7e5d308ca6412765927a96bd74601a5e  

## 8.24

### 新規ウィンドウがサブモニタで開くのを回避する方法
サブモニタを接続した状態で Dock のアイコンを右クリック  
「割り当て先」をウィンドウを開きたいディスプレイに設定  

サブモニタで開いておきたいウィンドウはウィンドウを開いてから手動で移動させる

### 『日本語入力を支える技術』
https://gihyo.jp/book/2012/978-4-7741-4993-6

サンプルコードは BSDL で提供されている

https://gihyo.jp/book/2012/978-4-7741-4993-6/support

購入しました

### Open Source IME

#### Akaza
https://github.com/akaza-im/mac-akaza  
https://github.com/akaza-im/akaza

#### GyaimMotion
https://github.com/masui/GyaimMotion

## 8.23

### Neovim で Lua のグローバル変数を確認する
`command-line mode` で以下を実行する

````
=_G
````

`_G` でグローバル変数を参照できる  
`=` は `lua print()` と同じ

### 行編集プログラム

#### Linenoise
https://github.com/antirez/linenoise

現在一般的に使われている端末エミュレータを対象とすることで実装を小さくしている  
ソースコードは 1,000 行程度

デフォルトでは 1 行編集だが、複数行編集モードも存在する  

#### Neovim command-line mode
https://neovim.io/doc/user/cmdline.html

#### Node.js Readline
https://nodejs.org/api/readline.html

https://github.com/nodejs/node/blob/v20.5.1/lib/readline.js  
https://github.com/nodejs/node/tree/v20.5.1/lib/internal/readline

#### libedit / editline
https://github.com/NetBSD/src/tree/trunk/lib/libedit  
https://man.netbsd.org/editline.3

#### tecla
https://sites.astro.caltech.edu/~mcs/tecla/

#### Readline
https://savannah.gnu.org/git/?group=readline

## 8.22

### Neovim のキーバインド
Markdown のパラグラフを挿入するキーバインドが欲しい

### symlink を管理するプログラム
Python で書く  
設定は configparser でストアする  

- 設定を保存する
- 保存された設定から symlink を張る
- 中間フォルダーを作成する

- symlink 作成先にファイルなどが存在するか確認する
- symlink 作成先が symlink 以外ならエラーを出力する
- symlink 作成先が symlink なら、リンクの先を確認する
- symlink のリンク先が設定と異なっていたらリンクを張り直す

- symlink を削除する
- 削除対象が symlink なら削除する
- 設定ファイルからも除外する

### Neovim でバッファの各行に対して Lua プログラムを実行する

`luado` を使用する。  
行データは `line` 変数に格納されている。  

````
luado print(line)
````

## 8.20

### 三項演算子について

こういう書き方はありなのかな

````js
const n = 10;

// prettier-ignore
const m = (n == 1)? n*10
        : (n == 10)? n*20
        : (n == 100)? n*30
        : n*40

console.log(m)
````

prettier の整形をスキップする方法は以下

https://prettier.io/docs/en/ignore.html

### LICENSE ファイルの年次の記載の更新について
https://www.gnu.org/prep/maintain/html_node/Copyright-Notices.html

プログラムを更新した年だけを含める

### Neovim 用の Lua REPL を作成したい
ビジュアルモードで選択した文字列を取得することはできなかったと思う。  
他の方法で対話的に Lua のコードを Neovim のコンテクストで実行する方法を探す。  

### Neovim 用の less モジュールを自作した
https://github.com/homma/config-files/blob/main/nvim/lua/less.lua  

個人的な用途ではこれで十分。  
余裕があれば、キーマップの保存・復帰にも対応したい。

### Neovim で keymap を保存・復帰する方法
https://neovim.io/doc/user/builtin.html#maparg()  
https://neovim.io/doc/user/builtin.html#mapcheck()  
https://neovim.io/doc/user/builtin.html#mapset()  

`maparg()`、`mapcheck()`、`mapset()` を使うみたい。  
`vim.fn.maparg()` で呼び出せる。

実行例。

````lua
lua print(vim.fn.maparg('<C-e>', 'i'))
-- => <End>
lua print(vim.fn.mapcheck('<C-e>', 'i'))
-- => <End>
````

大文字小文字は区別されない。

````lua
lua print(vim.fn.maparg('<c-e>', 'i'))
-- => <End>
````

設定されているかどうかは `''` と比較すれば良い。

````lua
lua print(vim.fn.maparg('<c-p>', 'i') == '')
````

返り値の長さでも判定できる。

````lua
lua print(#vim.fn.maparg('<c-x>', 'i') == 0)
````

これがあれば、モジュールで自由にキーバインドを変更して、モジュール終了時に元に戻すことができる。

## 8.19

### Neovim を less コマンドの代わりに使用する
https://github.com/neovim/neovim/blob/master/runtime/macros/less.vim  
https://github.com/neovim/neovim/blob/master/runtime/macros/less.sh  
https://neovim.io/doc/user/various.html#less  

`alias` に設定しておくと、less コマンドとして Neovim を使用することができる

普通の less との違いは color schema が適用されるくらいなのかな  
`v` で編集を開始できるのは同じ  

vi でファイルを開いてから less に移行するには以下のコマンドを実行する

````
:ru macros/less.vim
````

`:Less` で less に移行するには、以下を `init.lua` に設定する

````
vim.api.nvim_create_user_command('Less', 'runtime macros/less.vim', {})
````

### emacs-like insert mode がとても良い

vi の利点はモーダルであること。  
モードを切り替えて文章を編集することで、少ないキーストロークで多彩な編集を実行することができる。  

一方で、vi のデメリットもまたモーダルであること。  
モーダルであるため、モード内に実装されていない操作を実行するにはモードの切り替えが必要になる。  
例えば、挿入モードで編集した内容の保存は、一度ノーマルモードに戻って `:w` を入力することになる。  

特に挿入モード内だけで自由にテキストを編集することが難しい。  
カーソルを移動するだけでも、ホームポジションを崩して矢印キーを使うか、一旦ノーマルモードに切り替える必要がある。  
`<C-o>` で一度だけノーマルモードに戻る方法もあるが、繰り返し実行しようとすると煩雑になる。  

この問題を解決するのが `emacs-like insert mode`。  

emacs は vi のようなモーダルなエディタではない（emacs のモードは vi のモードとは異なる概念）。  
そのため、emacs を使いこなそうとすると、複数のキーを組み合わせた複雑なキーバインドを使用する必要がある。  
ただし、カーソル移動などの基本的なキー入力はとてもシンプルになっている。  
vi のノーマルモードのキー（`hjkl` など）と異なり、文字の挿入とキーが被ることもない。  

emacs のシンプルなキー入力の部分を vi の挿入モードで使用することができれば、テキスト編集がとても楽になる。  
モード切り替えが便利な場面ではモーダルの恩恵を享受することができ、最小ストロークで操作を実行できる。  
一方で、こまめにモードを切り替えたくない場面では、モードを切り替えることなく操作を実行できる。  

これを実現するには、Neovim の `init.lua` に以下を追加するだけで良い。  

````lua
-- emacs-like insert mode
vim.keymap.set('i', '<C-a>', '<Home>', { noremap = true })
vim.keymap.set('i', '<C-e>', '<End>', { noremap = true })
vim.keymap.set('i', '<C-b>', '<Left>', { noremap = true })
vim.keymap.set('i', '<C-f>', '<Right>', { noremap = true })
vim.keymap.set('i', '<C-p>', '<Up>', { noremap = true })
vim.keymap.set('i', '<C-n>', '<Down>', { noremap = true })
vim.keymap.set('i', '<C-l>', '<C-o>zz', { noremap = true })
vim.keymap.set('i', '<C-s>', '<C-o>:write<CR>', { noremap = true })
vim.keymap.set('i', '<C-q>', '<C-o>:quit<CR>', { noremap = true })
vim.keymap.set('i', '<C-d>', '<Del>', { noremap = true })
vim.keymap.set('i', '<C-k>', '<C-o>d$', { noremap = true })
````

macOS ユーザであれば、標準のテキストエディタアプリや、テキスト入力ボックスは emacs キーバインドが使用可能である。  
そのため、emacs キーバインドが vi の挿入モードでも使用できれば、大きなメリットがある。  

また、ターミナルのコマンドライン編集も emacs キーバインドで操作可能である。  
そのため、コマンドライン編集に慣れているならば、vi の挿入モードで emacs キーバインドを使用できることはメリットになる。  

同じような発想の Vim プラグインに `rsi.vim` が存在する。  

https://github.com/tpope/vim-rsi

同様の設定は GitHub 内だけでも数多く存在している。

https://github.com/search?q=vim+readline&type=repositories  
https://github.com/search?q=vim%20emacs%20insert%20mode&type=repositories

反対に、emcas をモーダルにするプログラムもある。

https://github.com/meow-edit/meow

Neovim のドキュメントにも Tips としてコマンドラインモードの Emacs-style なキーバインドについて記載がある。

https://neovim.io/doc/user/tips.html#emacs-keys  

## 8.15

### SRFI 49 を JavaScript にポーティングした
https://github.com/homma/srfi-49-js

Lisp は良い言語だと思うものの、S 式はちょっとしんどいなと思っていたので、パーサーの実装の勉強も兼ねて移植してみました  
コンパイラの教材は Lisp をターゲットにしたものが多いので、Lisp にトランスパイルするプログラムがあると良いなと思っていました

コードは元の実装そのままで JavaScript らしくないので、時間ができたら一から書き直したい

### SRFI 49 の `.` について
`.` を `EOF` 的に使用しているっぽい。

`read-block` の中で `read-item` の返り値に対して、`.` かどうかの判定をしている。  
コードを読んだ限りでは、`read-item` が `.` を返すことはなさそうに見える。  
`.` を返すのは `read-block-clean` ですが、`read-item` から `read-block-clean` が呼び出されるパスはなさそう。

### SRFI 49 の実装

#### Scheme
https://srfi.schemers.org/srfi-49/srfi-49.html  
https://github.com/ktakashi/sagittarius-scheme/blob/master/sitelib/srfi/%253a49.scm

#### Common Lisp
https://github.com/g000001/srfi-49/blob/master/srfi-49.lisp

### Lisp の苦手なところ
なんでもリストで表現する

````
class Person {
  name,
  age,
}
````

みたいなデータも

````
(name, age)
````

のように表現して `car` や `cdr` でアクセスしていることが多く、データにラベルがつかないので、読み下しづらい。  
値を作る時も `cons` を使っている。

関数から返る値が何を意味しているのかも明示的ではない。  
リストが返されていたとして、そのリストが何のデータなのかは一目見ただけでは分からない。

### SRFI 49: Indentation-sensitive syntax
https://srfi.schemers.org/srfi-49/srfi-49.html

## 8.14

### Prettier install
Nodebrew で Node.js をインストールした場合は、`~/.nodebrew/current/` 以下にインストールされる

````sh
% npm install -g prettier
````

`~/.npm` が作成されるが、不要そうなので消しておく

````sh
$ rm -rf ~/.npm
````

### `DARWIN_USER_DIR`
https://opensource.apple.com/source/Libc/Libc-1081.1.3/gen/confstr.3

````sh
$ getconf DARWIN_USER_DIR
$ touch $(getconf DARWIN_USER_DIR)foo.txt
````

アクセス許可不要でアプリに読み書きさせられるディレクトリ  
`/var/tmp` などを使うよりも良いのかもしれない

他のアプリから読み書きされても問題ないデータのみ配置して良い  
macOS のソフトウェアアップデートや再起動でデータが削除されるかもしれない  
rsync しておくと良いのかも

## 8.13

### Blender のダウンロード
スクリプトでバージョンを管理するため、CLI でダウンロードしたい

Homebrew でも NixPkgs でも `download.blender.org` からダウンロードしているみたい

https://github.com/Homebrew/homebrew-cask/blob/master/Casks/b/blender.rb  
https://github.com/NixOS/nixpkgs/blob/master/pkgs/applications/misc/blender/default.nix  

### Rust のインストール
````sh
$ cd
$ mkdir <installdir>/.cargo
$ ln -s <installdir>/.cargo .
$ mkdir <installdir>/.rustup
$ ln -s <installdir>/.rustup .
$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
````

#### evcxr
````sh
$ cargo install --locked evcxr_repl
$ alias rusti=evcxr
````

#### update
````sh
$ rustup update
````

#### uninstall
````sh
$ rustup self uninstall
````

### Neovim のリリースの確認
Neovim を Homebrew でインストールすると依存ソフトウェアが多い  
単体でバイナリを管理できると良い

````sh
% curl -s -O https://api.github.com/repos/neovim/neovim/releases
````

````sh
% cat releases | jq '.[].tag_name'
"nightly"
"v0.9.1"
"stable"
"v0.9.0"
"v0.8.3"
...
````

````sh
% cat releases | jq '.[] | select(.tag_name == "v0.9.1") .assets[].name'
"nvim-linux64.tar.gz"
"nvim-linux64.tar.gz.sha256sum"
"nvim-macos.tar.gz"
"nvim-macos.tar.gz.sha256sum"
...
````

#### Latest
`latest` ディレクトリにあるのは `stable`  
`stable` がどのバージョンであるかは `stable` 内では確認できない

````sh
% curl -s -O https://api.github.com/repos/neovim/neovim/releases/latest
````

````sh
% cat latest | jq '.tag_name'
"stable"
````

````sh
% cat latest | jq '.assets[].name'
"nvim-linux64.tar.gz"
"nvim-linux64.tar.gz.sha256sum"
"nvim-macos.tar.gz"
"nvim-macos.tar.gz.sha256sum"
...
````

`stable` に対応するバージョンは `target_commitish` 経由で確認できる

````sh
% curl -s https://api.github.com/repos/neovim/neovim/releases | jq '.[] | select(.tag_name == "stable").target_commitish'
"fe869a8ce25a14497a9bf5ddca0ae11a1c38a22c"
% curl -s https://api.github.com/repos/neovim/neovim/releases | jq '.[] | select(.target_commitish == "fe869a8ce25a14497a9bf5ddca0ae11a1c38a22c").tag_name'
"v0.9.2"
"stable"
````

現在インストールされているバージョンは以下のコマンドで確認可能

````sh
% nvim -v | grep NVIM | awk '{print $2}'
````

### Safari でウェブページの表示を拡大する
`設定...` -> `Web サイト` -> `ページの拡大/縮小` -> `これ以外の Web サイトでのデフォルト設定` -> `125%`

Firefox や Chrome でも同様に設定可能  
高精細・大画面のディスプレイでは必須設定だと思う  

#### スタイルシートでの設定
スタイルシートで拡大するとと一部のサイトで問題が起きる  
スタイルシートの指定は `Safari メニュー` -> `設定...` -> `詳細` -> `スタイルシート` で指定する

````css
body {
  zoom: 1.25;
}
````

JavaScript からは以下のように設定可能

````javascript
document.body.style.zoom = 1.25
````

参考  
https://developer.mozilla.org/ja/docs/Web/CSS/zoom

### Neovim のインストール時に実行しておくこと
config ファイルをインストールして、symlink を張る

https://github.com/homma/config-files/tree/main

`packer.nvim` のインストール

https://github.com/wbthomason/packer.nvim#quickstart

neovim を起動して `:PackerSync` でプラグインをインストールする

### Homebrew non-root install
しばらくは Homebrew を使うことにしました

````sh
$ cd
$ mkdir <installdir>/.homebrew
$ ln -s <installdir>/.homebrew .
$ curl -L https://github.com/Homebrew/brew/tarball/master | tar xz --strip 1 -C .homebrew
$ eval "$(.homebrew/bin/brew shellenv)"
$ brew update --force --quiet
$ chmod -R go-w "$(brew --prefix)/share/zsh"
$ echo 'export PATH=${HOME}/.homebrew/bin:${PATH}' >> ~/.zshrc
````

デフォルトのパスと異なるため、コンパイルが実行される

````sh
% brew install rsync
...
Warning: Building openssl@3 from source as the bottle needs:
...
built in 4 minutes 59 seconds
````

`brew install ripgrep` の場合はコンパイルは必要なかった

頻繁にインストール、アップグレードを実行するわけではないので、しばらくはこれで使ってみる

#### コンパイルが発生したパッケージ
- rsync
   - openssl のコンパイルが必要

#### コンパイルが発生しなかったパッケージ
- ripgrep
- jq
- stylua
- luajit
- hidapi
- raylib

#### 未インストール
- Neovim
   - 別途インストールしたため

### macOS で使用可能なパッケージシステム
non-root インストールしたい  
できれば Nixpkgs を使いたいところですが...

#### Homebrew
https://github.com/Homebrew/brew

non-root インストールは可能であるがサポートされていない

https://docs.brew.sh/Installation#untar-anywhere-unsupported  
https://github.com/Homebrew/brew/blob/master/docs/Installation.md#untar-anywhere-unsupported

#### Nixpkgs
https://github.com/nixos/nixpkgs

Linux では `nix-user-chroot` を使用することで non-root インストールも可能  
macOS では `nix-user-chroot` は使用できなさそう

https://nixos.wiki/wiki/Nix_Installation_Guide#Installing_without_root_permissions

`proot` や `nix-portable` を使用する方法も macOS では使用できないっぽい

#### MacPorts
https://www.macports.org

non-root インストール可能  
`--with-no-root-privileges` オプションを使用するみたい

https://gist.github.com/zadr/e9a090fb564451fb5c76db233fabf0d0  
https://gist.github.com/daggerok/d6c7ed8b9efa03b30ffd0e9f44cdd121

#### Fink
https://www.finkproject.org

dpkg ベース

#### pkgsrc
https://www.pkgsrc.org

non-root インストール可能  
`--unprivileged` オプションでユーザのホームディレクトリにインストールできる

https://www.netbsd.org/docs/pkgsrc/platforms.html

release は quarterly

https://www.pkgsrc.org/quarterly/

### Nix でパッケージをビルドする
https://github.com/justinwoo/nix-shorts/blob/master/posts/install-packages-from-files.md

### Nodebrew
実装は↓

https://github.com/hokaccha/nodebrew/blob/master/nodebrew

Node.js は↓の URL からダウンロードしている

https://nodejs.org/dist/

#### install
````sh
$ cd
$ mkdir <installdir>/.nodebrew
$ ln -s <installdir>/.nodebrew .
$ curl -L git.io/nodebrew | perl - setup
````

## 8.12

### パッケージ管理
ルートディレクトリではなく、ユーザのホームディレクトリ配下でパッケージを管理したい  

## 8.11

### YAML 風データのパース
既存の YAML のライブラリだと重複するキーがエラーになる

## 8.10

### BSD License のソフトウェアを fork した場合の LICENSE ファイルの書き方
https://github.com/openbsd/src/blob/master/usr.bin/vi/LICENSE

OpenBSD の LICENSE ファイルを参考にすればいい  
具体的には、Copyright ヘッダーを追加する

### MyLang をポーティングした
https://github.com/homma/mylang-js

Lexer にジェネレータを使用しているのが独特  
ジェネレータは先読みした時に値を戻せないという問題がある  
そのため、先読みした値を別途保存する必要性が発生している

JavaScript のジェネレータをちゃんと使ったのは初めてかも  
Map もあまり使ってこなかった  

しばらく前から class を型の代わりに使っているけど良い感じ

## 8.6

### 選択したテキストを右クリックでファイルに蓄積する

以下のスクリプトを作成し、Automator に登録した。  

Automator が改行コード `\n` を無視するので、`\n\0` を指定したら改行が出力された。  
`\n\0` の代わりに `\n\r` などでも良いみたい。  
謎の挙動。  

出力は `sjis` になる。  
`utf-8` にするのは大変そうだったので、今回は範囲外とします。  

````javascript
const app = Application.currentApplication();
app.includeStandardAdditions = true;

function appendToFile(text, file) {
  try {
    const fd = app.openForAccess(Path(file), { writePermission: true });

    app.write(text, { to: fd, startingAt: app.getEof(fd), as: "string" });
    app.closeAccess(fd);
    return true;
  } catch (e) {
    app.closeAccess(file);
    return false;
  }
}

function run(input, parameters) {
  // Automator ignores '\n' but '\n\0'
  const text = `${input[0]}\n\0`;

  // const output_dir = app.doShellScript("getconf DARWIN_USER_DIR");
  const output_dir = app.pathTo("home folder")
  const file = `${output_dir}/words.txt`;

  appendToFile(text, file);
}
````

参考  
https://developer.apple.com/library/archive/documentation/LanguagesUtilities/Conceptual/MacAutomationScriptingGuide/MakeaSystem-WideService.html

## 8.4

### YAML 的なものを parse する
- 行ごとに parse する // newline を見る
- インデント幅を変数に保持し、`INDENT` および `DEDENT` token を挿入する

- List と即値とコメントだけを扱いたいので、厳密には YAML ではない
   - yamlette

## 8.2

### evcxr
名前が覚えにくい  
eval context for rust  

名前を思い出しながら起動するので立ち上げが遅くなる  
alias をつけた方がいいかも  
rusti にしました

shared library を作成してロードするせいか、レスポンスが遅い  
これならインタープリタ方式の方が速くなるかもしれない  
CPU やファイルシステムが十分に速ければ問題ないのかもしれない

## 8.1

### cacao と cocoa どっち?
cacao は一般のアプリで使用されることを意図しているので、使いやすそう  
cocoa は servo で使用されているので、永続的に使用できそう

#### cacao
https://docs.rs/cacao/latest/cacao/  
https://crates.io/crates/cacao  
cocoa crate は servo と密結合しているので cacao create を作ったよとのこと  

https://docs.rs/cacao/latest/cacao/foundation/index.html  
cacao foundation は cocoa の core-foundation-rs の id の扱いに違和感があったからとのこと

#### cocoa
https://github.com/servo/core-foundation-rs  
https://blog1.mammb.com/entry/2023/03/03/182448  

Sample  
https://github.com/servo/core-foundation-rs/blob/master/cocoa/examples/hello_world.rs

#### RustKit
https://github.com/michaelwu/RustKit

### YAML S-exp
悪くないのでは

````
# fuctorial
- fun
- factorial
- - n
- - if
  - - ge
    - n
    - 1
  - 1
  - - multiply
    - n
    - - factorial
      - - minus
        - n
        - 1
````

````
# (list 1 2 "foo")
- list
- 1
- 2
- "foo"
````

````
# (+ 1 2 3 4)
- plus
- 1
- 2
- 3
- 4
````

````
# (lambda (x y) (+ x y))
- lambda
- - x
  - y
- - plus
  - x
  - y
````

#### another form
````
fun:
  name: factorial
  args:
    - n
  body:
    if:
      cond:
        ge:
         - n
         - 1
      true: 1
      false:
        multiply:
          - n
          - factorial:
              - minus:
                  - n
                  - 1
````

````
fun:
  - factorial
  - - n
  - if:
      - ge:
         - n
         - 1
      - 1
      - multiply:
          - n
          - factorial:
              - minus:
                  - n
                  - 1
````

````
fun:
  - factorial
  - [n]
  - if:
      - ge: [n, 1]
      - 1
      - multiply:
          - n
          - factorial:
              - minus: [n, 1]
````

````
# hello world
fun:
  - hello-world
  - []
  - print: 'hello world.'
````

````
# multi-line text
fun:
  - multi-line
  - []
  - print: |
      first line.
      second line.
````

````
fun:
  - program
  - [x, y]
  - begin:
      - let: [a, 10]
      - let: [b, 50]
      - print:
          +:
            - *: [a, x]
            - *: [b, y]
````

## 7.31

### Swift について
何度か Swift でプログラムを書こうとした後の印象

- Swift 自体は良い言語
- Swift に用意されている API を呼び出そうとすると、抽象度の高いものばかりで、実装したい操作まで辿り着くのが大変
  - フラグを変更したいだけなのに、専用の API がなく、ディクショナリに自分でデータを作成してから API を実行する必要があるなど
- Swift だけでは完結せず、C, ObjC, C++ を呼び出さざるを得なくなる
- 今でも ObjC ベースのドキュメントを参照する必要がある
- Swift のサンプルコードも少ない
- XCode が前提になっている
- REPL は使い勝手が良くない（起動が遅いし、プロンプトの設定もできない）

やりたいことを実装するのが大変で Swift を使うメリットが感じられない

例えば、USB デバイスを操作するプログラムを書くなら、IOKit などを使うよりも libusb を使った方が何倍も簡単  
PDF を編集するプログラムなら PDFKit より Python なんかで市井のライブラリを使った方が楽

### winit
https://komi.dev/post/2021-07-20-enabling-ime-in-alacritty/  
https://github.com/rust-windowing/winit/pull/1979

macOS でも日本語の入力に対応しているみたい

### REPL の実装に関するノート

基本は以下になるみたい
- コードをパースして、宣言、文、式などに分類する
- パースしたコードの種類に合わせてラッパーを追加する
- 変数や関数は専用のデータ構造を用意してストアする
- 変数や関数への参照はそちらを向くように書き換える
- 共有ライブラリとしてコンパイルする
- ロードして実行する
- REPL のプロセスと実行プロセスは分ける（サブプロセスにする）

共有ライブラリを作成できない言語では難しい  

#### Rust
https://github.com/evcxr/evcxr/blob/main/evcxr/HOW_IT_WORKS.md  
https://github.com/evcxr/evcxr/blob/main/COMMON.md#limitations

実装については冒頭に記載した形になっている  
他の Crate からマクロをインポートすることができないという制限がある

#### D
https://github.com/callumenator/dabble/blob/master/readme.md  
https://github.com/dlang-community/drepl/blob/master/src/drepl/engines/dmd.d

https://qiita.com/sobaya007/items/66876036bb318c368f5c  
https://karita.xyz/notes/d-jupyter.html

#### C
https://neugierig.org/software/c-repl/

#### Zig
https://github.com/ziglang/zig/issues/596

実装が難しいポイントが書かれている

#### Crystal
https://github.com/crystal-lang/crystal/issues/681

コンパイラとは別の実装として作成されている

#### Swift
https://www.swift.org/lldb/

デバッガを使用した特殊な実装  
起動が遅いのが難点

#### Go
Go 言語には冒頭に挙げたような実装の REPL は存在しないみたい  

https://github.com/x-motemen/gore

これは過去のコードを全て実行するみたいなので、逐次実行ではない

### "Building and loading dynamic libraries at runtime in Swift"
https://theswiftdev.com/building-and-loading-dynamic-libraries-at-runtime-in-swift/

### SwiftSyntax
https://github.com/apple/swift-syntax

これで REPL 作成できないかな

算術演算くらいなら実装できるかも

### 欲しいもの
このページのような雑記帳（マイクロブログ）

- Markdown で記入できる
- 文字数などの制限がない
- エントリー単位でデータを蓄積
  - title, body, date, tags
- 全てのエントリーを一覧表示できる
- 個別のエントリーを単独で表示できる
- タグで分類できる
- ログインしてデータを作成
- CLI からもデータを push 可能
- git で管理される

GitHub で実現できたら楽なのですが...

Issues を使う方法は abuse っぽい感じがする

https://egghead.io/blog/github-issues-powered-blog

ディレクトリに Markdown を作成したら、良い感じで読み出してほしい

### Python ctypes
https://docs.python.org/ja/3/library/ctypes.html

`CDLL` でライブラリをロードできる

### REPL for D Programming Language

#### drepl
https://github.com/dlang-community/drepl  
https://github.com/dlang-community/drepl/blob/master/src/drepl/interpreter.d  
https://github.com/dlang-community/drepl/blob/master/src/drepl/engines/dmd.d

以下のような操作で REPL を実現している
- 入力を宣言 (Decl)、文 (Stmt)、式 (Expr) に分別
- それぞれを C 言語のライブラリとしてコンパイル
- ライブラリをロード

変数の再定義やコンパイル単位をまたぐ参照をどうしているのかはよく分からず

Swift でも同じようなことができないかな

https://karita.xyz/notes/d-jupyter.html にも情報があった

#### dabble
https://github.com/callumenator/dabble

別の実装  
c-repl を参考にしているとのこと

https://neugierig.org/software/c-repl/

via https://forum.dlang.org/post/xemrxpwusliqsegkqtbx@forum.dlang.org

### OCaml and UTF8
https://rosettacode.org/wiki/String_length#Character_Length_72

UChar モジュールを使用すれば、文字列を UTF8 として操作する処理を実装できる
