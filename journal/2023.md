## 8.14

### `DARWIN_USER_DIR`
https://opensource.apple.com/source/Libc/Libc-1081.1.3/gen/confstr.3

````
$ getconf DARWIN_USER_DIR
$ touch $(getconf DARWIN_USER_DIR)foo.txt
````

アクセス許可不要でアプリに読み書きさせられるディレクトリ  
/var/tmp などを使うよりも良いのかもしれない

## 8.13

### Blender のダウンロード
スクリプトでバージョンを管理するため、CLI でダウンロードしたい

Homebrew でも NixPkgs でも `download.blender.org` からダウンロードしているみたい

https://github.com/Homebrew/homebrew-cask/blob/master/Casks/b/blender.rb  
https://github.com/NixOS/nixpkgs/blob/master/pkgs/applications/misc/blender/default.nix  

### Rust のインストール
````
$ cd
$ mkdir <installdir>/.cargo
$ ln -s <installdir>/.cargo .
$ mkdir <installdir>/.rustup
$ ln -s <installdir>/.rustup .
$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
````

#### evcxr
````
$ cargo install --locked evcxr_repl
$ alias rusti=evcxr
````

#### update
````
$ rustup update
````

#### uninstall
````
$ rustup self uninstall
````

### Neovim のリリースの確認
````
% curl -s -O https://api.github.com/repos/neovim/neovim/releases
````

````
% cat releases | jq '.[].tag_name'
"nightly"
"v0.9.1"
"stable"
"v0.9.0"
"v0.8.3"
...
````

````
% cat releases | jq '.[] | select(.tag_name == "v0.9.1") .assets[].name'
"nvim-linux64.tar.gz"
"nvim-linux64.tar.gz.sha256sum"
"nvim-macos.tar.gz"
"nvim-macos.tar.gz.sha256sum"
...
````

#### Latest
`latest` ディレクトリにあるのは `stable`  
`stable` がどのバージョンであるかは取得できない

````
 % curl -s -O https://api.github.com/repos/neovim/neovim/releases/latest
````

````
% cat latest | jq '.tag_name'
"stable"
````

````
% cat latest | jq '.assets[].name'
"nvim-linux64.tar.gz"
"nvim-linux64.tar.gz.sha256sum"
"nvim-macos.tar.gz"
"nvim-macos.tar.gz.sha256sum"
...
````

### Safari でウェブページの表示を拡大する

スタイルシートの設定でウェブページの表示を拡大・縮小できる  
以下をファイルに保存し、`Safari メニュー` -> `設定...` -> `詳細` -> `スタイルシート` で指定する

````
body {
  zoom: 1.25;
}
````

JavaScript からは以下のように設定可能

````
document.body.style.zoom = 1.25
````

https://developer.mozilla.org/ja/docs/Web/CSS/zoom

高精細・大画面のディスプレイでは必須設定だと思う

### Neovim のインストール時に実行しておくこと
config ファイルをインストールして、symlink を張る

https://github.com/homma/config-files/tree/main

packer.nvim のインストール

https://github.com/wbthomason/packer.nvim#quickstart

neovim を起動して `:PackerSync` でプラグインをインストールする

### Homebrew non-root install
しばらくは Homebrew を使うことにしました

````
$ cd
$ mkdir <installdir>/.homebrew
$ ln -s <installdir>/.homebrew .
$ curl -L https://github.com/Homebrew/brew/tarball/master | tar xz --strip 1 -C .homebrew
$ eval "$(.homebrew/bin/brew shellenv)"
$ brew update --force --quiet
$ chmod -R go-w "$(brew --prefix)/share/zsh"
$ echo 'export PATH=${HOME}/.homebrew/bin:${PATH}' >> ~/.zshrc
````

デフォルトのパスと異なるため、コンパイルが実行される

````
% brew install rsync
...
Warning: Building openssl@3 from source as the bottle needs:
...
built in 4 minutes 59 seconds
````

`brew install ripgrep` の場合はコンパイルは必要なかった

頻繁にインストール、アップグレードを実行するわけではないので、しばらくはこれで使ってみる

#### コンパイルが発生したパッケージ
- rsync
   - openssl のコンパイルが必要

#### コンパイルが発生しなかったパッケージ
- ripgrep
- jq

#### 未インストール
- Neovim
   - 別途インストールしたため
- stylua
   - 現時点では使用していない

### macOS で使用可能なパッケージシステム
non-root インストールしたい  
できれば Nixpkgs を使いたいところですが...

#### Homebrew
https://github.com/Homebrew/brew

non-root インストールは可能であるがサポートされていない

https://docs.brew.sh/Installation#untar-anywhere-unsupported  
https://github.com/Homebrew/brew/blob/master/docs/Installation.md#untar-anywhere-unsupported

#### Nixpkgs
https://github.com/nixos/nixpkgs

Linux では `nix-user-chroot` を使用することで non-root インストールも可能  
macOS では `nix-user-chroot` は使用できなさそう

https://nixos.wiki/wiki/Nix_Installation_Guide#Installing_without_root_permissions

`proot` や `nix-portable` を使用する方法も macOS では使用できないっぽい

#### MacPorts
https://www.macports.org

non-root インストール可能  
`--with-no-root-privileges` オプションを使用するみたい

https://gist.github.com/zadr/e9a090fb564451fb5c76db233fabf0d0  
https://gist.github.com/daggerok/d6c7ed8b9efa03b30ffd0e9f44cdd121

#### Fink
https://www.finkproject.org

dpkg ベース

#### pkgsrc
https://www.pkgsrc.org

non-root インストール可能  
`--unprivileged` オプションでユーザのホームディレクトリにインストールできる

https://www.netbsd.org/docs/pkgsrc/platforms.html

release は quarterly

https://www.pkgsrc.org/quarterly/

### Nix でパッケージをビルドする
https://github.com/justinwoo/nix-shorts/blob/master/posts/install-packages-from-files.md

### Nodebrew
実装は↓

https://github.com/hokaccha/nodebrew/blob/master/nodebrew

Node.js は↓の URL からダウンロードしている

https://nodejs.org/dist/

#### install
````
$ cd
$ mkdir <installdir>/.nodebrew
$ ln -s <installdir>/.nodebrew .
$ curl -L git.io/nodebrew | perl - setup
````

## 8.12

### パッケージ管理
ルートディレクトリではなく、ユーザのホームディレクトリ配下でパッケージを管理したい  

## 8.11

### YAML 風データのパース
既存の YAML のライブラリだと重複するキーがエラーになる

## 8.10

### BSD License のソフトウェアを fork した場合の LICENSE ファイルの書き方
https://github.com/openbsd/src/blob/master/usr.bin/vi/LICENSE

OpenBSD の LICENSE ファイルを参考にすればいい  
具体的には、Copyright ヘッダーを追加する

### MyLang をポーティングした
https://github.com/homma/mylang-js

Lexer にジェネレータを使用しているのが独特  
ジェネレータは先読みした時に値を戻せないという問題がある  
そのため、先読みした値を別途保存する必要性が発生している

JavaScript のジェネレータをちゃんと使ったのは初めてかも  
Map もあまり使ってこなかった  

しばらく前から class を型の代わりに使っているけど良い感じ

## 8.6

### 選択したテキストを右クリックでファイルに蓄積する

以下のスクリプトを作成し、Automator に登録した。  

Automator が改行コード `\n` を無視するので、`\n\0` を指定したら改行が出力された。  
`\n\0` の代わりに `\n\r` などでも良いみたい。  
謎の挙動。  

出力は `sjis` になる。  
`utf-8` にするのは大変そうだったので、今回は範囲外とします。  

`DARWIN_USER_DIR` はデフォルトで書き込み可能なディレクトリ（別途許可する必要がない）  
https://opensource.apple.com/source/Libc/Libc-1081.1.3/gen/confstr.3

````
const app = Application.currentApplication();
app.includeStandardAdditions = true;

function appendToFile(text, file) {
  try {
    const fd = app.openForAccess(Path(file), { writePermission: true });

    app.write(text, { to: fd, startingAt: app.getEof(fd), as: "string" });
    app.closeAccess(fd);
    return true;
  } catch (e) {
    app.closeAccess(file);
    return false;
  }
}

function run(input, parameters) {
  // Automator ignores '\n' but '\n\0'
  const text = `${input[0]}\n\0`;

  const output_dir = app.doShellScript('getconf DARWIN_USER_DIR');
  const file = `${output_dir}/words.txt`;

  appendToFile(text, file);
}
````

保存されたデータは以下のコマンドで確認できる

````
$ cat $(getconf DARWIN_USER_DIR)words.txt
````

参考
- https://developer.apple.com/library/archive/documentation/LanguagesUtilities/Conceptual/MacAutomationScriptingGuide/MakeaSystem-WideService.html

## 8.4

### YAML 的なものを parse する
- 行ごとに parse する // newline を見る
- インデント幅を変数に保持し、`INDENT` および `DEDENT` token を挿入する

- List と即値とコメントだけを扱いたいので、厳密には YAML ではない
   - yamlette

## 8.2

### evcxr
名前が覚えにくい  
eval context for rust  

名前を思い出しながら起動するので立ち上げが遅くなる  
alias をつけた方がいいかも  
rusti にしました

shared library を作成してロードするせいか、レスポンスが遅い  
これならインタープリタ方式の方が速くなるかもしれない  
CPU やファイルシステムが十分に速ければ問題ないのかもしれない

## 8.1

### cacao と cocoa どっち?
cacao は一般のアプリで使用されることを意図しているので、使いやすそう  
cocoa は servo で使用されているので、永続的に使用できそう

#### cacao
https://docs.rs/cacao/latest/cacao/  
https://crates.io/crates/cacao  
cocoa crate は servo と密結合しているので cacao create を作ったよとのこと  

https://docs.rs/cacao/latest/cacao/foundation/index.html  
cacao foundation は cocoa の core-foundation-rs の id の扱いに違和感があったからとのこと

#### cocoa
https://github.com/servo/core-foundation-rs  
https://blog1.mammb.com/entry/2023/03/03/182448  

Sample  
https://github.com/servo/core-foundation-rs/blob/master/cocoa/examples/hello_world.rs

#### RustKit
https://github.com/michaelwu/RustKit

### YAML S-exp
悪くないのでは

````
# fuctorial
- fun
- factorial
- - n
- - if
  - - ge
    - n
    - 1
  - 1
  - - multiply
    - n
    - - factorial
      - - minus
        - n
        - 1
````

````
# (list 1 2 "foo")
- list
- 1
- 2
- "foo"
````

````
# (+ 1 2 3 4)
- plus
- 1
- 2
- 3
- 4
````

````
# (lambda (x y) (+ x y))
- lambda
- - x
  - y
- - plus
  - x
  - y
````

#### another form
````
fun:
  name: factorial
  args:
    - n
  body:
    if:
      cond:
        ge:
         - n
         - 1
      true: 1
      false:
        multiply:
          - n
          - factorial:
              - minus:
                  - n
                  - 1
````

````
fun:
  - factorial
  - - n
  - if:
      - ge:
         - n
         - 1
      - 1
      - multiply:
          - n
          - factorial:
              - minus:
                  - n
                  - 1
````

````
fun:
  - factorial
  - [n]
  - if:
      - ge: [n, 1]
      - 1
      - multiply:
          - n
          - factorial:
              - minus: [n, 1]
````

````
# hello world
fun:
  - hello-world
  - []
  - print: 'hello world.'
````

````
# multi-line text
fun:
  - multi-line
  - []
  - print: |
      first line.
      second line.
````

````
fun:
  - program
  - [x, y]
  - begin:
      - let: [a, 10]
      - let: [b, 50]
      - print:
          +:
            - *: [a, x]
            - *: [b, y]
````

## 7.31

### Swift について
何度か Swift でプログラムを書こうとした後の印象

- Swift 自体は良い言語
- Swift に用意されている API を呼び出そうとすると、抽象度の高いものばかりで、実装したい操作まで辿り着くのが大変
  - フラグを変更したいだけなのに、専用の API がなく、ディクショナリに自分でデータを作成してから API を実行する必要があるなど
- Swift だけでは完結せず、C, ObjC, C++ を呼び出さざるを得なくなる
- 今でも ObjC ベースのドキュメントを参照する必要がある
- Swift のサンプルコードも少ない
- XCode が前提になっている
- REPL は使い勝手が良くない（起動が遅いし、プロンプトの設定もできない）

やりたいことを実装するのが大変で Swift を使うメリットが感じられない

例えば、USB デバイスを操作するプログラムを書くなら、IOKit などを使うよりも libusb を使った方が何倍も簡単  
PDF を編集するプログラムなら PDFKit より Python なんかで市井のライブラリを使った方が楽

### winit
https://komi.dev/post/2021-07-20-enabling-ime-in-alacritty/  
https://github.com/rust-windowing/winit/pull/1979

macOS でも日本語の入力に対応しているみたい

### REPL の実装に関するノート

基本は以下になるみたい
- コードをパースして、宣言、文、式などに分類する
- パースしたコードの種類に合わせてラッパーを追加する
- 変数や関数は専用のデータ構造を用意してストアする
- 変数や関数への参照はそちらを向くように書き換える
- 共有ライブラリとしてコンパイルする
- ロードして実行する
- REPL のプロセスと実行プロセスは分ける（サブプロセスにする）

共有ライブラリを作成できない言語では難しい  

#### Rust
https://github.com/evcxr/evcxr/blob/main/evcxr/HOW_IT_WORKS.md  
https://github.com/evcxr/evcxr/blob/main/COMMON.md#limitations

実装については冒頭に記載した形になっている  
他の Crate からマクロをインポートすることができないという制限がある

#### D
https://github.com/callumenator/dabble/blob/master/readme.md  
https://github.com/dlang-community/drepl/blob/master/src/drepl/engines/dmd.d

https://qiita.com/sobaya007/items/66876036bb318c368f5c  
https://karita.xyz/notes/d-jupyter.html

#### C
https://neugierig.org/software/c-repl/

#### Zig
https://github.com/ziglang/zig/issues/596

実装が難しいポイントが書かれている

#### Crystal
https://github.com/crystal-lang/crystal/issues/681

コンパイラとは別の実装として作成されている

#### Swift
https://www.swift.org/lldb/

デバッガを使用した特殊な実装  
起動が遅いのが難点

#### Go
Go 言語には冒頭に挙げたような実装の REPL は存在しないみたい  

https://github.com/x-motemen/gore

これは過去のコードを全て実行するみたいなので、逐次実行ではない

### "Building and loading dynamic libraries at runtime in Swift"
https://theswiftdev.com/building-and-loading-dynamic-libraries-at-runtime-in-swift/

### SwiftSyntax
https://github.com/apple/swift-syntax

これで REPL 作成できないかな

算術演算くらいなら実装できるかも

### 欲しいもの
このページのような雑記帳（マイクロブログ）

- Markdown で記入できる
- 文字数などの制限がない
- エントリー単位でデータを蓄積
  - title, body, date, tags
- 全てのエントリーを一覧表示できる
- 個別のエントリーを単独で表示できる
- タグで分類できる
- ログインしてデータを作成
- CLI からもデータを push 可能
- git で管理される

GitHub で実現できたら楽なのですが...

Issues を使う方法は abuse っぽい感じがする

https://egghead.io/blog/github-issues-powered-blog

ディレクトリに Markdown を作成したら、良い感じで読み出してほしい

### Python ctypes
https://docs.python.org/ja/3/library/ctypes.html

`CDLL` でライブラリをロードできる

### REPL for D Programming Language

#### drepl
https://github.com/dlang-community/drepl  
https://github.com/dlang-community/drepl/blob/master/src/drepl/interpreter.d  
https://github.com/dlang-community/drepl/blob/master/src/drepl/engines/dmd.d

以下のような操作で REPL を実現している
- 入力を宣言 (Decl)、文 (Stmt)、式 (Expr) に分別
- それぞれを C 言語のライブラリとしてコンパイル
- ライブラリをロード

変数の再定義やコンパイル単位をまたぐ参照をどうしているのかはよく分からず

Swift でも同じようなことができないかな

https://karita.xyz/notes/d-jupyter.html にも情報があった

#### dabble
https://github.com/callumenator/dabble

別の実装  
c-repl を参考にしているとのこと

https://neugierig.org/software/c-repl/

via https://forum.dlang.org/post/xemrxpwusliqsegkqtbx@forum.dlang.org

### OCaml and UTF8
https://rosettacode.org/wiki/String_length#Character_Length_72

UChar モジュールを使用すれば、文字列を UTF8 として操作する処理を実装できる
